{"K":{"EntityId":3450,"EntityName":4,"Options":"N","Product":{"u":3450,"t":"","Avatar":"#","n":"Repository Pattern with Caching and Hangfire in ASP.NET Core","sd":"In this article, we will learn about an approach with which we will build a SUPER-FAST Repository Implementation using all the latest libraries and concepts. We will be implementing Repository Pattern with Caching and Hangfire in ASP.NET Core along with Onion Architecture just to make sure our code is well organized and be readily used in any random project.","fd":"&lt;h2&gt;The Requirement&lt;/h2&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo;s have a simple ASP.NET Core 3.1 WebAPI that does CRUD operations over a Customer Entity. That&amp;rsquo;s quite simple, yeah? But we will try to make this API return much faster than it would do traditionally. How can we achieve this? Caching, of-course. The first question is where would you implement caching? The ideal layer would be to couple it somehow with the Repository layer, so that every time you work with the Repository Layer, your results are being cached.&lt;/p&gt;\r\n\r\n&lt;p&gt;The other requirement is to implement a generic caching where-in the user can have the flexibility to use different caching techs like In-Memory, Redis, and so on. Finally, let&amp;rsquo;s integrate caching with Hangfire so that it runs in the background at specific triggers.&lt;/p&gt;\r\n&lt;iframe id=\"google_ads_iframe_/1254144/codewithmukesh_com-medrectangle-4_0\" title=\"3rd party ad content\" name=\"google_ads_iframe_/1254144/codewithmukesh_com-medrectangle-4_0\" width=\"728\" height=\"90\" scrolling=\"no\" marginwidth=\"0\" marginheight=\"0\" frameborder=\"0\" sandbox=\"allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation\" allow=\"conversion-measurement ‘src’\" srcdoc=\"\" data-google-container-id=\"j\" data-load-complete=\"true\"&gt;&lt;/iframe&gt;\r\n\r\n&lt;p&gt;So, the idea is simple. We will build a traditional Repository Pattern along with the DBContext of Entity Framework Core. Every time a user requests for Customer data, we need to check if it already exists in the cache, else retrieve it from DB and cache it. And whenever someone deletes or modifies a record, the cached data should get invalidated and recached. Caching again may take some time. Thus, we set this caching process as a background job. Simple? Let&amp;rsquo;s get started!&lt;br /&gt;\r\n&lt;br /&gt;\r\n&amp;nbsp;&lt;/p&gt;\r\n\r\n&lt;h2&gt;Tech-Stack And Concepts&lt;/h2&gt;\r\n\r\n&lt;ol&gt;\r\n\t&lt;li&gt;ASP.NET Core 3.1 WebAPI&lt;/li&gt;\r\n\t&lt;li&gt;Onion Architecture&lt;/li&gt;\r\n\t&lt;li&gt;Entity Framework Core&lt;/li&gt;\r\n\t&lt;li&gt;Generic Repository Pattern&lt;/li&gt;\r\n\t&lt;li&gt;Generic Caching to support various caching techs&lt;/li&gt;\r\n\t&lt;li&gt;Hangfire to process Caching Jobs in the background&lt;/li&gt;\r\n\t&lt;li&gt;Single Interface with Multiple Implementations**&lt;/li&gt;\r\n&lt;/ol&gt;\r\n\r\n&lt;h2&gt;Getting Started &amp;ndash; Repository Pattern With Caching And Hangfire In ASP.NET Core&lt;/h2&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo;s get started by creating a new&amp;nbsp;&lt;strong&gt;Blank Solution&amp;nbsp;&lt;/strong&gt;in Visual Studio 2019 IDE and adding in 3 New Projects. Clean Architecture, Remember?&lt;/p&gt;\r\n\r\n&lt;ol&gt;\r\n\t&lt;li&gt;ASP.NET Core 3.1 WebAPI. I named it Web&lt;/li&gt;\r\n\t&lt;li&gt;.NET Core 3.1 Library &amp;ndash; Let&amp;rsquo;s name it Core. The entities and Interfaces will live here.&lt;/li&gt;\r\n\t&lt;li&gt;.NET Core 3.1 Library &amp;ndash; Name it Infrastructure. Everything related to EFCore, Caching, Hangfire will be implemented here.&lt;/li&gt;\r\n&lt;/ol&gt;\r\n\r\n&lt;h2&gt;Customer Model&lt;/h2&gt;\r\n\r\n&lt;p&gt;In this Core Project, add a new folder and name it Entities. Here create a new class, Customer.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public class Customer\r\n{\r\n    public int Id { get; set; }\r\n    public string FirstName { get; set; }\r\n    public string LastName { get; set; }\r\n    public string Contact { get; set; }\r\n    public string Email { get; set; }\r\n    public DateTime DateOfBirth { get; set; }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;h2&gt;Adding Entity Framework Core And Context&lt;/h2&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo; add the required EFCore packages to the Infrastructure Project.&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code&gt;Install-Package Microsoft.EntityFrameworkCore\r\nInstall-Package Microsoft.EntityFrameworkCore.Tools\r\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer\r\nInstall-Package Microsoft.EntityFrameworkCore.Design\r\nInstall-Package Microsoft.VisualStudio.Web.CodeGeneration.Design&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Similarly, add the following packages to the API Project.&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code&gt;Install-Package Microsoft.EntityFrameworkCore.Tools\r\nInstall-Package Microsoft.EntityFrameworkCore.SqlServer\r\nInstall-Package Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore\r\nInstall-Package Microsoft.VisualStudio.Web.CodeGeneration.Design&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;&lt;br /&gt;\r\nEFCore Implementations belongs to the Infrastructure Layer of our Solution. In the Infrastructure project, add a new Folder Data and create a new class, ApplicationDbContext.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code&gt;public class ApplicationDbContext : DbContext\r\n{\r\n    public ApplicationDbContext(DbContextOptions&amp;lt;ApplicationDbContext&amp;gt; options) : base(options)\r\n    {\r\n        ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;\r\n    }\r\n    public DbSet&amp;lt;Customer&amp;gt; Customers { get; set; }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Now, we will have to register EFCore into the Service container of the ASP.NET Core Application. For this, open up Startup.cs and add the following to the ConfigureServices Method.&lt;/p&gt;\r\nNext, open up appsettings.json and add in the connection string to your database. Note that I have used SQLServer instance in this article.\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-JSON\"&gt;\"ConnectionStrings\": {\r\n\"DefaultConnection\": \"your connection string here\"\r\n},&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;That&amp;rsquo;s it for the EFCore part. Open Package Manager Console on Visual Studio and run the following commands. This will essentially add in all the Entity Framework Core Migrations and update your database (the one that you have mentioned in your connection string).&lt;br /&gt;\r\n&amp;nbsp;&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-JSON\"&gt;add-migration initial\r\nupdate-database&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Make sure that you have set the API Project as the Startup Project , and the Infrastructure Project as the Default Project. (You can find this dropdown at the top corner of the Package Manager Console)&lt;/p&gt;\r\n\r\n&lt;h2&gt;Add Caching Service&lt;/h2&gt;\r\n\r\n&lt;p&gt;Caching is the Heart of our concept. With caching, we ensure that users can request data from our API without waiting for a considerable amount of time. So, when the 1st user requests for all customer data, it goes to the DB, fetches the records, and also caches this data to either application memory or any external cache service like Redis.&lt;/p&gt;\r\n\r\n&lt;p&gt;Now, when the second user requests for the same data, it wouldn&amp;rsquo;t make sense to fetch from the database, as it can be a bit time consuming, right? And since we already have the data cached, why not return it? This saves the consequent requests a lot of time, literally a lot.&lt;/p&gt;\r\n\r\n&lt;p&gt;The first question is what is the customer data changed during the time between 1st request and the 2nd, 3rd request? If we still serve the cached data, that&amp;rsquo;s essentially invalid, right? So, the apt solution is every time there is a modification to the Customer Collection, we will have to remove the cache and recache it somehow with Hangfire.&lt;/p&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo;s start building a generic Caching Service. The main intention is to future proof our solution so that we can integrate various Caching Techniques as and when required by the application.&lt;/p&gt;\r\n\r\n&lt;p&gt;If you are new to the concept of caching, here are a few MUST Read articles on&lt;a aria-label=\" In-Memory Caching (opens in a new tab)\" href=\"https://codewithmukesh.com/blog/in-memory-caching-in-aspnet-core/\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;&amp;nbsp;In-Memory Caching&lt;/a&gt;&amp;nbsp;and&amp;nbsp;&lt;a aria-label=\"Redis Caching in ASP.NET Core (opens in a new tab)\" href=\"https://codewithmukesh.com/blog/redis-caching-in-aspnet-core/\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;Redis Caching in ASP.NET Core&lt;/a&gt;. Make sure you read them before continuing.&lt;/p&gt;\r\n\r\n&lt;p&gt;We will need to specify certain configurations related to Caching. Let&amp;rsquo;s use the IOptions Pattern to read the settings directly from appsettings.json. In the Core Project, add a new folder and name it Configurations. Here, add a new class named CacheConfiguration.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public class CacheConfiguration\r\n{\r\n   public int AbsoluteExpirationInHours { get; set; }\r\n   public int SlidingExpirationInMinutes { get; set; }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo;s add it to the service container of the application. Open Startup.cs and add in the following under the ConfigureServices method.&lt;/p&gt;\r\nservices.Configure&amp;lt;CacheConfiguration&amp;gt;(Configuration.GetSection(&amp;quot;CacheConfiguration&amp;quot;));\r\n\r\n&lt;p&gt;With that done, open appsettings.json and add in the following config.&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-JSON\"&gt;\"CacheConfiguration\": {\r\n   \"AbsoluteExpirationInHours\": 1,\r\n   \"SlidingExpirationInMinutes\": 30\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;SlidingExpirationInMinutes refers to the duration in minutes within which the cache will be cleared if there is so request from any user.&lt;/p&gt;\r\n\r\n&lt;p&gt;AbsoluteExpirationInHours refers to the duration in Hours within which the cache will be cleared even if there are requests from the users. These configurations enable maximum efficiency and minimal response times keeping in check that the cache is always valid and the users are not being served outdated information.&lt;/p&gt;\r\n\r\n&lt;h3&gt;&lt;strong&gt;Single Interface with Multiple Implementations&lt;/strong&gt;&lt;/h3&gt;\r\n\r\n&lt;p&gt;Next, as mentioned earlier, we will be designing our system to accommodate multiple cache techniques like in-memory and Redis, and so on. This calls for a&amp;nbsp;&lt;strong&gt;Concept of Single Interface with Multiple Implementations&lt;/strong&gt;.&lt;/p&gt;\r\n\r\n&lt;p&gt;So, the idea is that we know before hand that all the cache techniques will have 3 Core functions, Get the data, Set the Data and Remove the Cached data. Thus we will build a common interface, ICacheService that defines these 3 functions. And the implementation will be multiple, like MemoryCacheService and RedisCacheService. Get the point?&lt;/p&gt;\r\n\r\n&lt;p&gt;But, before that, let&amp;rsquo;s add in an Enum that consists of the supported Caching Techniques. In the core Project, add a new folder, Enums. Here add a new class CacheTech.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-JSON\"&gt;public enum CacheTech\r\n{\r\n  Redis,\r\n  Memory\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;You can see that we have added Redis and Memory as options. This can be extended as per your requirment. Let&amp;rsquo;s build our ICacheService interface now. In the Core Project, add another folder named Interfaces. Remember that, with clean architecture all the interface should be at the Core of the application. This Inverts the Dependencies and the Application no longer depends on the implementation, but only on the interface.&lt;/p&gt;\r\n\r\n&lt;p&gt;Under the Interface folder, add in ICacheService.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public interface ICacheService\r\n{\r\n  bool TryGet&amp;lt;T&amp;gt;(string cacheKey, out T value);\r\n  T Set&amp;lt;T&amp;gt;(string cacheKey, T value);\r\n  void Remove(string cacheKey);\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;There you go, as mentioned earlier, we defined our 3 Major functions in the interface. Now, let&amp;rsquo;s proceed with the implementation. For this article, we will be only implementing In-Memory Caching. I will leave Redis caching to you. For reference to Redis caching implementation,&amp;nbsp;&lt;a aria-label=\"please see this article (opens in a new tab)\" href=\"https://codewithmukesh.com/blog/redis-caching-in-aspnet-core/\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;please see this article&lt;/a&gt;.&lt;/p&gt;\r\n\r\n&lt;p&gt;Implementations live in the Infrastructure layer. In the Infrastructure Project, add a new folder, Services. Here, add in a new class, MemoryCacheService.cs&lt;br /&gt;\r\n&lt;br /&gt;\r\n&amp;nbsp;&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public class MemoryCacheService: ICacheService\r\n{\r\n    private readonly IMemoryCache _memoryCache;\r\n    private readonly CacheConfiguration _cacheConfig;\r\n    private MemoryCacheEntryOptions _cacheOptions;\r\n    public MemoryCacheService(IMemoryCache memoryCache, IOptions&amp;lt;CacheConfiguration&amp;gt; cacheConfig)\r\n    {\r\n        _memoryCache = memoryCache;\r\n        _cacheConfig = cacheConfig.Value;\r\n        if (_cacheConfig != null)\r\n        {\r\n            _cacheOptions = new MemoryCacheEntryOptions\r\n            {\r\n                AbsoluteExpiration = DateTime.Now.AddHours(_cacheConfig.AbsoluteExpirationInHours),\r\n                Priority = CacheItemPriority.High,\r\n                SlidingExpiration = TimeSpan.FromMinutes(_cacheConfig.SlidingExpirationInMinutes)\r\n            };\r\n        }\r\n    }\r\n    public bool TryGet&amp;lt;T&amp;gt;(string cacheKey, out T value)\r\n    {\r\n        _memoryCache.TryGetValue(cacheKey, out value);\r\n        if (value == null) return false;\r\n        else return true;\r\n    }\r\n    public T Set&amp;lt;T&amp;gt;(string cacheKey, T value)\r\n    {\r\n        return _memoryCache.Set(cacheKey, value, _cacheOptions);\r\n    }\r\n    public void Remove(string cacheKey)\r\n    {\r\n        _memoryCache.Remove(cacheKey);\r\n    }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Note &amp;ndash; If you are not very aware of the above implementation, please refer to the Detailed Article on&amp;nbsp;&lt;a aria-label=\"In-Memory Caching in ASP.NET Core here. (opens in a new tab)\" href=\"https://codewithmukesh.com/blog/in-memory-caching-in-aspnet-core/\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;In-Memory Caching in ASP.NET Core here.&lt;/a&gt;&lt;/p&gt;\r\n\r\n&lt;p&gt;Similarly, add in another class, this time for Redis. Let&amp;rsquo;s name it RedisCacheService.cs&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;services.Configure&amp;lt;CacheConfiguration&amp;gt;(Configuration.GetSection(\"CacheConfiguration\"));\r\n//For In-Memory Caching\r\nservices.AddMemoryCache();\r\nservices.AddTransient&amp;lt;MemoryCacheService&amp;gt;();\r\nservices.AddTransient&amp;lt;RedisCacheService&amp;gt;();\r\nservices.AddTransient&amp;lt;Func&amp;lt;CacheTech, ICacheService&amp;gt;&amp;gt;(serviceProvider =&amp;gt; key =&amp;gt;\r\n{\r\n    switch (key)\r\n    {\r\n        case CacheTech.Memory:\r\n            return serviceProvider.GetService&amp;lt;MemoryCacheService&amp;gt;();\r\n        case CacheTech.Redis:\r\n            return serviceProvider.GetService&amp;lt;RedisCacheService&amp;gt;();\r\n        default:\r\n            return serviceProvider.GetService&amp;lt;MemoryCacheService&amp;gt;();\r\n    }\r\n});&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;&lt;br /&gt;\r\nPlease note that we have not implemented RedisCache as of now.&lt;/p&gt;\r\n\r\n&lt;p&gt;Finally, let&amp;rsquo;s register our Cache Services. Open Startup.cs and add in the following to the ConfigureServices method.&lt;br /&gt;\r\n&amp;nbsp;&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;services.Configure&amp;lt;CacheConfiguration&amp;gt;(Configuration.GetSection(\"CacheConfiguration\"));\r\n//For In-Memory Caching\r\nservices.AddMemoryCache();\r\nservices.AddTransient&amp;lt;MemoryCacheService&amp;gt;();\r\nservices.AddTransient&amp;lt;RedisCacheService&amp;gt;();\r\nservices.AddTransient&amp;lt;Func&amp;lt;CacheTech, ICacheService&amp;gt;&amp;gt;(serviceProvider =&amp;gt; key =&amp;gt;\r\n{\r\n    switch (key)\r\n    {\r\n        case CacheTech.Memory:\r\n            return serviceProvider.GetService&amp;lt;MemoryCacheService&amp;gt;();\r\n        case CacheTech.Redis:\r\n            return serviceProvider.GetService&amp;lt;RedisCacheService&amp;gt;();\r\n        default:\r\n            return serviceProvider.GetService&amp;lt;MemoryCacheService&amp;gt;();\r\n    }\r\n});&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Line 1 &amp;ndash; Adds the Configurations settings to the container so that it can be accessed later on via the IOptions Pattern.&lt;br /&gt;\r\nLine 3 &amp;ndash; 5 Adds the InMemoryCache and Redis Service to the container.&lt;/p&gt;\r\n\r\n&lt;p&gt;For a single interface injection to work with multiple implementations, we have to define it as a funciton that accepts the previoustly created Enum as a parameters. Inside it will be a very simple switch statement that returns the service as requeried.&lt;/p&gt;\r\n\r\n&lt;p&gt;For example, if you pass CacheTech.Redis, this function should return RedisCacheSerive to the calling method, constructor. Get the idea?&lt;/p&gt;\r\n\r\n&lt;h2&gt;Setting Up Hangfire&lt;/h2&gt;\r\n\r\n&lt;p&gt;Hangfire is one of the best Background Job Processing Library ever. Let&amp;rsquo;s use this awesome library to improve our application&amp;rsquo;s effeciency ever further. Again, Hangfire belongs to the Infrastructure project. So, install the following package to the Infrastructure Project.&lt;/p&gt;\r\nInstall-Package Hangfire\r\n\r\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\r\nFor this article, we will be using the API Project as the Server that will process the jobs enqueud to Hangfire. In some cases it makes sense to create a Blank ASP.NET Core Application and install Hangfire in it. This isolates the application and Hangfire would not interfere with the Resources of the API Server. But here, let&amp;rsquo;s just use our API as the Hangfire Server.\r\n\r\n&lt;p&gt;In the API/Startup.cs file, add in the following under the ConfigureServices method. Note that we will also be using the same connection string to store in Hangfire job data.&lt;/p&gt;\r\nservices.AddHangfire(x =&amp;gt; x.UseSqlServerStorage(Configuration.GetConnectionString(&amp;quot;DefaultConnection&amp;quot;)));&lt;br /&gt;\r\nservices.AddHangfireServer();\r\n&lt;p&gt;Finally, in the Configure Method, add the following. This determines the path at which you will be able to monitor the Hangfire Jobs via it&amp;rsquo;s awesome Dashboard.&lt;/p&gt;\r\napp.UseHangfireDashboard(&amp;quot;/jobs&amp;quot;);\r\n\r\n&lt;p&gt;Hangfire is pretty awesome. In this article, we limit the functionality of Hangfire to only what we require. Hangfire is capable of much more than this. To learn in-depth about everything Hangfire can do,&amp;nbsp;&lt;a aria-label=\"refer to this article. (opens in a new tab)\" href=\"https://codewithmukesh.com/blog/hangfire-in-aspnet-core-3-1/\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;refer to this article.&lt;/a&gt;&lt;/p&gt;\r\n\r\n&lt;h2&gt;Adding Repository Interfaces And Implementations&lt;/h2&gt;\r\n\r\n&lt;p&gt;&amp;nbsp;&lt;/p&gt;\r\nWith the Caching and Hangfire done, most of the complex parts of the implementation are taken care of. Let&amp;rsquo;s switch to the basic Repository Pattern implementation. At the Core/Interfaces folder, add in 2 More interfaces as below, IGenericRepository.cs and ICustomerRepository.cs\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public interface IGenericRepository&amp;lt;T&amp;gt; where T : class\r\n{\r\n   Task&amp;lt;T&amp;gt; GetByIdAsync(int id);\r\n   Task&amp;lt;IReadOnlyList&amp;lt;T&amp;gt;&amp;gt; GetAllAsync();\r\n   Task&amp;lt;T&amp;gt; AddAsync(T entity);\r\n   Task UpdateAsync(T entity);\r\n   Task DeleteAsync(T entity);\r\n}\r\npublic interface ICustomerRepository : IGenericRepository&amp;lt;Customer&amp;gt;\r\n{\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Now, in the Infrastructure Project, add a new Folder , Repositories. Here add in 2 files, that is the implementation of the previous interfaces.&lt;/p&gt;\r\n\r\n&lt;p&gt;First, let&amp;rsquo;s add GenericRepository.cs&lt;br /&gt;\r\n&amp;nbsp;&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public class GenericRepository&amp;lt;T&amp;gt; : IGenericRepository&amp;lt;T&amp;gt; where T : class\r\n{\r\n    private readonly static CacheTech cacheTech = CacheTech.Memory;\r\n    private readonly string cacheKey = $\"{typeof(T)}\";\r\n    private readonly ApplicationDbContext _dbContext;\r\n    private readonly Func&amp;lt;CacheTech, ICacheService&amp;gt; _cacheService;\r\n    public GenericRepository(ApplicationDbContext dbContext, Func&amp;lt;CacheTech, ICacheService&amp;gt; cacheService)\r\n    {\r\n        _dbContext = dbContext;\r\n        _cacheService = cacheService;\r\n    }\r\n    public virtual async Task&amp;lt;T&amp;gt; GetByIdAsync(int id)\r\n    {\r\n        return await _dbContext.Set&amp;lt;T&amp;gt;().FindAsync(id);\r\n    }\r\n    public async Task&amp;lt;IReadOnlyList&amp;lt;T&amp;gt;&amp;gt; GetAllAsync()\r\n    {\r\n        if (!_cacheService(cacheTech).TryGet(cacheKey, out IReadOnlyList&amp;lt;T&amp;gt; cachedList))\r\n        {\r\n            cachedList = await _dbContext.Set&amp;lt;T&amp;gt;().ToListAsync();\r\n            _cacheService(cacheTech).Set(cacheKey, cachedList);\r\n        }\r\n        return cachedList;\r\n    }\r\n    public async Task&amp;lt;T&amp;gt; AddAsync(T entity)\r\n    {\r\n        await _dbContext.Set&amp;lt;T&amp;gt;().AddAsync(entity);\r\n        await _dbContext.SaveChangesAsync();\r\n        BackgroundJob.Enqueue(() =&amp;gt; RefreshCache());\r\n        return entity;\r\n    }\r\n    public async Task UpdateAsync(T entity)\r\n    {\r\n        _dbContext.Entry(entity).State = EntityState.Modified;\r\n        await _dbContext.SaveChangesAsync();\r\n        BackgroundJob.Enqueue(() =&amp;gt; RefreshCache());\r\n    }\r\n    public async Task DeleteAsync(T entity)\r\n    {\r\n        _dbContext.Set&amp;lt;T&amp;gt;().Remove(entity);\r\n        await _dbContext.SaveChangesAsync();\r\n        BackgroundJob.Enqueue(() =&amp;gt; RefreshCache());\r\n    }\r\n    public async Task RefreshCache()\r\n    {\r\n        _cacheService(cacheTech).Remove(cacheKey);\r\n        var cachedList = await _dbContext.Set&amp;lt;T&amp;gt;().ToListAsync();\r\n        _cacheService(cacheTech).Set(cacheKey, cachedList);\r\n    }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Line 3 &amp;ndash; Here we are specifying the Caching Technique we wish to use. Here it is In-Memory Caching.&lt;br /&gt;\r\nLine 4 &amp;ndash; Since this is a generic Implementation, we will have to define the name of the key used to cache. Caching is more like a dictionary with key value pair. With key as the identifier, the data is stored. Hence, here the key will be the name of the Class itself, i.e Customer&lt;/p&gt;\r\n\r\n&lt;p&gt;Line 6 &amp;ndash; Here we use the Function that returns the service instance as required.&lt;/p&gt;\r\n\r\n&lt;p&gt;We will not be caching the Result of GetByID because it is usually a very fast performing query. We will need caching only when the user requests for all Data or modifies any.&lt;/p&gt;\r\n\r\n&lt;p&gt;Line 16 &amp;ndash; 23 &amp;ndash; Here to the _cacheService, we pass the selected cacheTech (Memory) as a parameter and try to check if any data exists. If not, get the data from the DB and set it to the cache and finally return the data to the user. By now, the data is readily available in the cache for the subsequent requests.&lt;/p&gt;\r\n\r\n&lt;p&gt;Note that if, instead of Memory you specify the cache tech as Redis, the API would throw a Not Implemented Exception as the service itself is not implemented yet.&lt;/p&gt;\r\n\r\n&lt;p&gt;Adding, Updating, Deleting means that there is a modification in the Data Collection, right? Hence I made a common method, RefreshCache that removes the existing data from the cache for that particular cache key and re-query the database to load the cache again.&lt;/p&gt;\r\n\r\n&lt;p&gt;Note that this method may be time-consuming depending on the amount of data involved. Hence at Line 29, 36, and 42, we are adding the RefreshCache function as a Background Job to Hangfire to ease the process. Pretty smooth theoretically, yeah?&lt;/p&gt;\r\n\r\n&lt;p&gt;Finally, let&amp;rsquo;s implement CustomerRepository which will contain nothing special for now, as all the awesomeness is implemented at the Generic Repository.&amp;nbsp;&lt;strong&gt;But, note that the constructor injection remains similar.&lt;/strong&gt;&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;public class CustomerRepository : GenericRepository&amp;lt;Customer&amp;gt;, ICustomerRepository\r\n{\r\n  private readonly DbSet&amp;lt;Customer&amp;gt; _customer;\r\n  public CustomerRepository(ApplicationDbContext dbContext, Func&amp;lt;CacheTech, ICacheService&amp;gt; cacheService) : base(dbContext, cacheService)\r\n{\r\n  _customer = dbContext.Set&amp;lt;Customer&amp;gt;();\r\n}\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;p&gt;Open the Startup.cs and add in the following code under the ConfigureServices to register the repositories.&lt;/p&gt;\r\n#region Repositories&lt;br /&gt;\r\nservices.AddTransient(typeof(IGenericRepository&amp;lt;&amp;gt;), typeof(GenericRepository&amp;lt;&amp;gt;));&lt;br /&gt;\r\nservices.AddTransient&amp;lt;ICustomerRepository, CustomerRepository&amp;gt;();&lt;br /&gt;\r\n#endregion\r\n&lt;h2&gt;Wiring Up With The API Controller&lt;/h2&gt;\r\n\r\n&lt;p&gt;Now that everything is done, let&amp;rsquo;s build up our API Controller. In the Controller folder, add a new Empty API Controller and name it CustomerController. This is a very straight-forward code snippet that uses up the ICustomerRepository Interface to perform CRUD Operations.&lt;/p&gt;\r\n\r\n&lt;pre&gt;\r\n&lt;code class=\"language-csharp\"&gt;[Route(\"api/[controller]\")]\r\n[ApiController]\r\npublic class CustomerController : ControllerBase\r\n{\r\n    private readonly ICustomerRepository _repository;\r\n    public CustomerController(ICustomerRepository repository)\r\n    {\r\n        this._repository = repository;\r\n    }\r\n    [HttpGet]\r\n    public async Task&amp;lt;IReadOnlyList&amp;lt;Customer&amp;gt;&amp;gt; Get()\r\n    {\r\n        return await _repository.GetAllAsync();\r\n    }\r\n    [HttpGet(\"{id}\")]\r\n    public async Task&amp;lt;ActionResult&amp;lt;Customer&amp;gt;&amp;gt; Get(int id)\r\n    {\r\n        var customer = await _repository.GetByIdAsync(id);\r\n        if (customer == null)\r\n        {\r\n            return NotFound();\r\n        }\r\n        return customer;\r\n    }\r\n    [HttpPut(\"{id}\")]\r\n    public async Task&amp;lt;IActionResult&amp;gt; Put(int id, Customer customer)\r\n    {\r\n        if (id != customer.Id)\r\n        {\r\n            return BadRequest();\r\n        }\r\n        await _repository.UpdateAsync(customer);\r\n        return NoContent();\r\n    }\r\n    [HttpPost]\r\n    public async Task&amp;lt;ActionResult&amp;lt;Customer&amp;gt;&amp;gt; Post(Customer customer)\r\n    {\r\n        await _repository.AddAsync(customer);\r\n        return CreatedAtAction(\"Get\", new { id = customer.Id }, customer);\r\n    }\r\n    [HttpDelete(\"{id}\")]\r\n    public async Task&amp;lt;ActionResult&amp;lt;Customer&amp;gt;&amp;gt; Delete(int id)\r\n    {\r\n        var customer = await _repository.GetByIdAsync(id);\r\n        if (customer == null)\r\n        {\r\n            return NotFound();\r\n        }\r\n        await _repository.DeleteAsync(customer);\r\n        return customer;\r\n    }\r\n}&lt;/code&gt;&lt;/pre&gt;\r\n\r\n&lt;h2&gt;Test Data&lt;/h2&gt;\r\n\r\n&lt;p&gt;For test purposes, I am adding in around 1000 Dummy Customer Records.&lt;a aria-label=\" You can find the SQL Insert Script here. (opens in a new tab)\" href=\"https://github.com/iammukeshm/RepositoryPatternWithCachingAndHangfire/blob/master/SampleCustomers.sql\" rel=\"noreferrer noopener\" target=\"_blank\"&gt;&amp;nbsp;You can find the SQL Insert Script here.&lt;/a&gt;&lt;/p&gt;\r\n\r\n&lt;h2&gt;Testing With Postman&lt;/h2&gt;\r\n\r\n&lt;p&gt;We will be using Postman to run Tests. But before that, run the application and navigate to /jobs.&lt;/p&gt;\r\n\r\n&lt;figure&gt;&lt;img alt=\"hangfire Repository Pattern with Caching and Hangfire in ASP.NET Core\" height=\"517\" loading=\"lazy\" sizes=\"(max-width: 1024px) 100vw, 1024px\" src=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/hangfire-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg\" srcset=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/hangfire-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg 1024w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-300x151.jpg 300w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-768x388.jpg 768w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-1536x775.jpg 1536w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-610x308.jpg 610w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-1080x545.jpg 1080w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-1280x646.jpg 1280w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-980x495.jpg 980w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire-480x242.jpg 480w, https://codewithmukesh.com/wp-content/uploads/2020/10/hangfire.jpg 1920w\" title=\"Repository Pattern with Caching and Hangfire in ASP.NET Core 1\" width=\"1024\" /&gt;&lt;/figure&gt;\r\n\r\n&lt;p&gt;You can see the Hangfire is up and running. Note that you may see a rather blank graph.&lt;/p&gt;\r\n\r\n&lt;p&gt;Open up POSTMAN and send a GET Request to https://localhost:xxxx/api/customer&lt;/p&gt;\r\n\r\n&lt;figure&gt;&lt;img alt=\"Postman 1Ul4lTSJGP Repository Pattern with Caching and Hangfire in ASP.NET Core\" height=\"585\" loading=\"lazy\" sizes=\"(max-width: 923px) 100vw, 923px\" src=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-1ul4ltsjgp-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg\" srcset=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-1ul4ltsjgp-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg 923w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_1Ul4lTSJGP-300x190.jpg 300w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_1Ul4lTSJGP-768x487.jpg 768w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_1Ul4lTSJGP-610x387.jpg 610w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_1Ul4lTSJGP-480x304.jpg 480w\" title=\"Repository Pattern with Caching and Hangfire in ASP.NET Core 2\" width=\"923\" /&gt;&lt;/figure&gt;\r\n\r\n&lt;p&gt;You can see that the API returns all the 1000 sets of customer record in under 1 second. That is still acceptable, but with caching you can see the improvement considerably. Theoretically, after the first request all the 1000 customer data is cached. So, the second request should take much lesser time. Let&amp;rsquo;s request one more time.&lt;/p&gt;\r\n\r\n&lt;figure&gt;&lt;img alt=\"Postman qJPYRhlDIt Repository Pattern with Caching and Hangfire in ASP.NET Core\" loading=\"lazy\" sizes=\"(max-width: 925px) 100vw, 925px\" src=\"https://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-qjpyrhldit-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg\" srcset=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-qjpyrhldit-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg 925w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_qJPYRhlDIt-300x189.jpg 300w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_qJPYRhlDIt-768x484.jpg 768w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_qJPYRhlDIt-610x384.jpg 610w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_qJPYRhlDIt-480x303.jpg 480w\" style=\"width: 925px; height: 583px;\" title=\"Repository Pattern with Caching and Hangfire in ASP.NET Core 3\" /&gt;&lt;/figure&gt;\r\n\r\n&lt;p&gt;There you go. From 1 second to under 25 milliseconds. Quite a noticeable performance improvement,yeah?&lt;/p&gt;\r\n\r\n&lt;p&gt;Now, let&amp;rsquo; s try to modify the records set by adding in a new customer. By theory, this action should invalidate the existing cache and fire the RefreshCache function and set it to Hangfire. Let&amp;rsquo;s see.&lt;/p&gt;\r\n\r\n&lt;figure&gt;&lt;img alt=\"Postman ihF1V8J8po Repository Pattern with Caching and Hangfire in ASP.NET Core\" loading=\"lazy\" sizes=\"(max-width: 926px) 100vw, 926px\" src=\"https://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-ihf1v8j8po-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg\" srcset=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/postman-ihf1v8j8po-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg 926w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_ihF1V8J8po-300x183.jpg 300w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_ihF1V8J8po-768x468.jpg 768w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_ihF1V8J8po-610x372.jpg 610w, https://codewithmukesh.com/wp-content/uploads/2020/10/Postman_ihF1V8J8po-480x292.jpg 480w\" style=\"width: 926px; height: 564px;\" title=\"Repository Pattern with Caching and Hangfire in ASP.NET Core 4\" /&gt;&lt;/figure&gt;\r\n\r\n&lt;figure&gt;&lt;img alt=\"chrome otnZiN152v Repository Pattern with Caching and Hangfire in ASP.NET Core\" height=\"397\" loading=\"lazy\" sizes=\"(max-width: 1024px) 100vw, 1024px\" src=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/chrome-otnzin152v-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg\" srcset=\"http://storage.selectgo.vn/media/uploads-1/images/images/2021/03/24/chrome-otnzin152v-repository-pattern-with-caching-and-hangfire-in-asp-net-core.jpg 1024w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-300x116.jpg 300w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-768x298.jpg 768w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-610x236.jpg 610w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-1080x419.jpg 1080w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-980x380.jpg 980w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v-480x186.jpg 480w, https://codewithmukesh.com/wp-content/uploads/2020/10/chrome_otnZiN152v.jpg 1223w\" title=\"Repository Pattern with Caching and Hangfire in ASP.NET Core 5\" width=\"1024\" /&gt;&lt;/figure&gt;\r\n\r\n&lt;p&gt;Now switch back to your Hangfire Dashboard. By the time you open up Hangfire, the job should have already been processed. Click on the Jobs Tab. You might see a new Succeeded Job. This means that our cache has been reloaded properly. Pretty cool yeah?&lt;/p&gt;\r\n\r\n&lt;p&gt;Let&amp;rsquo;s wrap up the article.&lt;/p&gt;\r\n","ManageInventoryMethodId":0,"DisableBuyButton":0,"DisableWishlistButton":false,"DisplayStatus":false,"IsFocus":true,"AvailableForPreOrder":false,"pr":0.00,"DisplayPrice":0.00,"SpecialPriceByPercent":0,"PriceIncludesVat":false,"RelatedProducts":"","CrossSells":"","AssociatedProducts":"","do":0,"AllowCustomerReviews":true,"StoreAppliedIds":"6,","Viewed":71,"o":true,"CreatedTime":"2021-03-24T08:54:41.54","LastModified":"2021-03-25T09:16:52.7","UpdatedTimeAgo":"25/03/2021 09:16:52","pic":{"Url":"#","Title":"","Products":[],"ProductPictureMappings":[],"Albums":[],"AlbumPictureMappings":[],"BlogPostPictureMappings":[]},"ProductTemplate":{"Name":"Plugins & Snippets Templates ","ViewPath":"Catalog::Product::Default_Plugin"},"ProductType":{"Name":"Plugins & Snippets Item"},"ProductProductTagMappings":[],"ProductCategoryMappings":[{"cid":30,"Category":{"u":30,"n":"Plugins & Snippets","g":"plugins-resources","o":true,"sids":"6,","c2":[],"Parent":{"u":1,"n":"<<ROOT>>","c2":[],"pcm":[]},"cp":{"u":1,"n":"<<ROOT>>","c2":[],"pcm":[]},"pcm":[]}},{"cid":35,"Category":{"u":35,"n":"Snippets","g":"linked-by-1176","o":true,"sids":"6,","c2":[],"Parent":{"u":30,"n":"Plugins & Snippets","c2":[],"pcm":[]},"cp":{"u":30,"n":"Plugins & Snippets","c2":[],"pcm":[]},"pcm":[]}},{"cid":67,"Category":{"u":67,"n":"ASP.NET Core","g":"linked-by-3653","o":true,"sids":"6,","c2":[],"Parent":{"u":35,"n":"Snippets","c2":[],"pcm":[]},"cp":{"u":35,"n":"Snippets","c2":[],"pcm":[]},"pcm":[]}}],"ProductManufacturerMappings":[{"ManufacturerId":1,"Manufacturer":{"Id":1,"Name":"huyvd.","Description":"Vũ Đình Huy","Avatar":"https://via.placeholder.com/292x164/999/FFF/?text=Prefer:292x164+(px)&textsize=36","IsActive":true,"StoreAppliedIds":"6,","ProductManufacturerMappings":[]}}],"ipic":[],"ProductSpecificationAttributeMappings":[{"SpecificationAttributeOptionId":66,"SpecificationAttributeOptionIdArray":"[66]","CustomValue":"2021/03/24","ShowOnProductPage":true,"DisplayOrder":1,"SpecificationAttributeOption":{"Id":66,"SpecificationAttributeId":9,"Name":"Declared # Value","DisplayOrder":9,"ProductSpecificationAttributeMappings":[],"SpecificationAttribute":{"Id":9,"Name":"Last Update","DisplayOrder":1,"IsActive":true,"SpecificationAttributeOptions":[]}}},{"SpecificationAttributeOptionId":60,"SpecificationAttributeOptionIdArray":"[60]","CustomValue":"https://codewithmukesh.com/blog/repository-pattern-caching-hangfire-aspnet-core/","ShowOnProductPage":true,"DisplayOrder":1,"SpecificationAttributeOption":{"Id":60,"SpecificationAttributeId":13,"Name":"Declared # Value","DisplayOrder":9,"ProductSpecificationAttributeMappings":[],"SpecificationAttribute":{"Id":13,"Name":"Link Target","DisplayOrder":1,"IsActive":true,"SpecificationAttributeOptions":[]}}},{"SpecificationAttributeOptionId":44,"SpecificationAttributeOptionIdArray":"[44]","ShowOnProductPage":true,"DisplayOrder":1,"SpecificationAttributeOption":{"Id":44,"SpecificationAttributeId":15,"Name":"None","DisplayOrder":9,"ProductSpecificationAttributeMappings":[],"SpecificationAttribute":{"Id":15,"Name":"License","DisplayOrder":1,"IsActive":true,"SpecificationAttributeOptions":[]}}},{"SpecificationAttributeOptionId":54,"SpecificationAttributeOptionIdArray":"[54]","CustomValue":"https://github.com/iammukeshm/RepositoryPatternWithCachingAndHangfire","ShowOnProductPage":true,"DisplayOrder":1,"SpecificationAttributeOption":{"Id":54,"SpecificationAttributeId":17,"Name":"Declared # Value","DisplayOrder":9,"ProductSpecificationAttributeMappings":[],"SpecificationAttribute":{"Id":17,"Name":"Fork on GitHub","DisplayOrder":1,"IsActive":true,"SpecificationAttributeOptions":[]}}},{"SpecificationAttributeOptionId":53,"SpecificationAttributeOptionIdArray":"[53]","CustomValue":"iammukeshm","ShowOnProductPage":true,"DisplayOrder":1,"SpecificationAttributeOption":{"Id":53,"SpecificationAttributeId":18,"Name":"Declared # Value","DisplayOrder":9,"ProductSpecificationAttributeMappings":[],"SpecificationAttribute":{"Id":18,"Name":"Authors","DisplayOrder":1,"IsActive":true,"SpecificationAttributeOptions":[]}}}],"ProductAttributeMappings":[],"ProductTierPrices":[],"BlogPostProductMappings":[],"ProductMetaAttributeMappings":[],"ProductAssociateMappings":[]},"ProductListSelectOptionViews":[],"ListCategoryByProduct":"30,35,67,","Alternate":"[{\"storeId\":1,\"hreflang\":\"en-US\",\"title\":\"English\",\"href\":\"/repository-pattern-with-caching-and-hangfire-in-asp-net-core.html\"}]"}}